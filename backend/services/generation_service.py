# backend/services/generation_service.py

from typing import Any, Dict, Optional

from utils.logger import get_logger

logger = get_logger(__name__)


class GenerationService:
    """
    Core service that takes a GenerateRequest-like object (from routers.generate)
    and returns all the artefacts InfraGenie can generate.

    Currently rule-based for predictable output.
    Later you can plug in AI via utils.prompts.
    """

    async def generate(self, payload: Any) -> Dict[str, Any]:
        language = getattr(payload, "language", "python")
        framework = getattr(payload, "framework", None)
        cicd_tool = getattr(payload, "cicd_tool", "github_actions")
        deploy_target = getattr(payload, "deploy_target", "kubernetes")
        cloud_provider = getattr(payload, "cloud_provider", "aws")
        include_gitops = getattr(payload, "include_gitops", True)
        include_monitoring = getattr(payload, "include_monitoring", False)
        infra_preset = getattr(payload, "infra_preset", "all")  # eks | ec2 | ecs | all | none

        logger.info(
            "Starting infra generation",
            extra={
                "language": language,
                "framework": framework,
                "cicd_tool": cicd_tool,
                "deploy_target": deploy_target,
                "cloud_provider": cloud_provider,
            },
        )

        # ---------------- Dockerfile ----------------
        dockerfile = self._generate_dockerfile(language, framework)

        # ---------------- CI/CD ----------------
        # We want both filename + content, but API returns only content as string
        cicd_data = self._generate_cicd(cicd_tool, language, framework)
        cicd_content = cicd_data.get("content", "")
        cicd_meta = cicd_data  # full dict: {"filename": ..., "content": ...}

        # ---------------- K8s / Helm ----------------
        k8s_manifests = (
            self._generate_k8s_manifests(language, framework)
            if deploy_target in ("kubernetes", "helm")
            else None
        )

        helm_chart = (
            self._generate_helm_chart(language, framework)
            if deploy_target == "helm"
            else None
        )

        # ---------------- GitOps / ArgoCD ----------------
        argocd_app = (
            self._generate_argocd_app(cloud_provider=cloud_provider)
            if include_gitops
            else None
        )

        # ---------------- Monitoring ----------------
        monitoring_configs = (
            self._generate_monitoring_configs() if include_monitoring else None
        )

        # ---------------- Terraform ----------------
        terraform_configs = self._generate_terraform_configs(cloud_provider, infra_preset)

        # ---------------- Meta ----------------
        raw: Dict[str, Any] = {
            "meta": {
                "language": language,
                "framework": framework,
                "cicd_tool": cicd_tool,
                "deploy_target": deploy_target,
                "cloud_provider": cloud_provider,
                "infra_preset": infra_preset,
            }
        }

        return {
            "dockerfile": dockerfile,
            "cicd_config": cicd_content,      # string for API / frontend
            "cicd_meta": cicd_meta,           # dict for ZIP builder
            "k8s_manifests": k8s_manifests,
            "helm_chart": helm_chart,
            "argocd_app": argocd_app,
            "monitoring_configs": monitoring_configs,
            "terraform_configs": terraform_configs,
            "raw": raw,
        }

    # ---------------------- Dockerfile ---------------------- #

    def _generate_dockerfile(self, language: str, framework: Optional[str]) -> str:
        language = (language or "").lower()
        framework = (framework or "").lower()

        if language == "python":
            return self._dockerfile_python(framework)
        if language in ("node", "nodejs", "javascript", "js"):
            return self._dockerfile_node(framework)

        # Default fallback
        return (
            "# Generic Dockerfile generated by InfraGenie\n"
            "# TODO: adjust base image and commands for your stack.\n"
            "FROM alpine:3.19\n"
            "WORKDIR /app\n"
            "COPY . /app\n"
            "CMD [\"sh\"]\n"
        )

    def _dockerfile_python(self, framework: Optional[str]) -> str:
        """
        Basic Python Dockerfile with best-practice flags and requirements.
        """
        app_cmd = "python app.py"
        if framework in ("fastapi",):
            app_cmd = "uvicorn main:app --host 0.0.0.0 --port 8000"

        return (
            "# Python Dockerfile generated by InfraGenie\n"
            "FROM python:3.11-slim\n\n"
            "ENV PYTHONDONTWRITEBYTECODE=1 \\\n"
            "    PYTHONUNBUFFERED=1\n\n"
            "WORKDIR /app\n"
            "COPY requirements.txt /app/\n"
            "RUN pip install --no-cache-dir -r requirements.txt\n\n"
            "COPY . /app\n\n"
            "# Expose application port\n"
            "EXPOSE 5000\n\n"
            "# Start the application\n"
            f'CMD ["bash", "-c", "{app_cmd}"]\n'
        )

    def _dockerfile_node(self, framework: Optional[str]) -> str:
        """
        Node.js Dockerfile with separate dependency layer.
        """
        return (
            "# Node.js Dockerfile generated by InfraGenie\n"
            "FROM node:20-alpine\n\n"
            "WORKDIR /app\n"
            "COPY package*.json ./\n"
            "RUN npm install --production\n\n"
            "COPY . .\n\n"
            "# Expose application port\n"
            "EXPOSE 3000\n\n"
            "# Start the application\n"
            'CMD ["npm", "start"]\n'
        )

    # ---------------------- CI/CD ---------------------- #

    def _generate_cicd(
        self,
        cicd_tool: str,
        language: str,
        framework: Optional[str]
    ) -> Dict[str, str]:
        """
        Returns:
            {
                "filename": "Jenkinsfile" | "github-actions.yaml" | ".gitlab-ci.yml",
                "content": "<file contents>"
            }
        """
        tool = cicd_tool.lower()

        if tool == "github_actions":
            return {
                "filename": "github-actions.yaml",
                "content": self._github_actions_workflow(language, framework),
            }

        if tool == "jenkins":
            return {
                "filename": "Jenkinsfile",
                "content": self._jenkinsfile(language, framework),
            }

        if tool == "gitlab_ci":
            return {
                "filename": ".gitlab-ci.yml",
                "content": self._gitlab_ci(language, framework),
            }

        # fallback
        return {
            "filename": "pipeline.yaml",
            "content": (
                "# Unknown CI/CD tool requested.\n"
                "# Please choose: github_actions | jenkins | gitlab_ci.\n"
            ),
        }

    def _github_actions_workflow(self, language: str, framework: Optional[str]) -> str:
        return (
            "# GitHub Actions workflow generated by InfraGenie\n"
            "name: InfraGenie CI\n\n"
            "on:\n"
            "  push:\n"
            "    branches: [ main ]\n"
            "  pull_request:\n"
            "    branches: [ main ]\n\n"
            "jobs:\n"
            "  build-and-push:\n"
            "    runs-on: ubuntu-latest\n\n"
            "    steps:\n"
            "      - name: Checkout\n"
            "        uses: actions/checkout@v4\n\n"
            "      - name: Set up Docker Buildx\n"
            "        uses: docker/setup-buildx-action@v3\n\n"
            "      - name: Login to Docker Hub\n"
            "        uses: docker/login-action@v3\n"
            "        with:\n"
            "          username: ${{ secrets.DOCKERHUB_USERNAME }}\n"
            "          password: ${{ secrets.DOCKERHUB_TOKEN }}\n\n"
            "      - name: Build and push image\n"
            "        uses: docker/build-push-action@v5\n"
            "        with:\n"
            "          context: .\n"
            "          push: true\n"
            "          tags: ${{ secrets.DOCKERHUB_USERNAME }}/your-app:latest\n"
        )

    def _jenkinsfile(self, language: str, framework: Optional[str]) -> str:
        return (
            "// Jenkinsfile generated by InfraGenie\n"
            "pipeline {\n"
            "  agent any\n\n"
            "  environment {\n"
            "    IMAGE = 'your-dockerhub-user/your-image'\n"
            "  }\n\n"
            "  stages {\n"
            "    stage('Checkout') {\n"
            "      steps {\n"
            "        checkout scm\n"
            "      }\n"
            "    }\n\n"
            "    stage('Build') {\n"
            "      steps {\n"
            "        sh 'docker build -t $IMAGE:latest .'\n"
            "      }\n"
            "    }\n\n"
            "    stage('Push') {\n"
            "      steps {\n"
            "        withCredentials([usernamePassword(credentialsId: 'dockerhub-creds', usernameVariable: 'USER', passwordVariable: 'PASS')]) {\n"
            "          sh 'echo $PASS | docker login -u $USER --password-stdin'\n"
            "          sh 'docker push $IMAGE:latest'\n"
            "        }\n"
            "      }\n"
            "    }\n"
            "  }\n"
            "}\n"
        )

    def _gitlab_ci(self, language: str, framework: Optional[str]) -> str:
        return (
            "# .gitlab-ci.yml generated by InfraGenie\n"
            "stages:\n"
            "  - build\n"
            "  - push\n\n"
            "variables:\n"
            "  IMAGE_NAME: your-registry/your-image\n\n"
            "build:\n"
            "  stage: build\n"
            "  script:\n"
            "    - docker build -t $IMAGE_NAME:latest .\n\n"
            "push:\n"
            "  stage: push\n"
            "  script:\n"
            "    - docker push $IMAGE_NAME:latest\n"
        )

    # ---------------------- Kubernetes ---------------------- #

    def _generate_k8s_manifests(
        self, language: str, framework: Optional[str]
    ) -> Dict[str, str]:
        deployment_yaml = (
            "apiVersion: apps/v1\n"
            "kind: Deployment\n"
            "metadata:\n"
            "  name: app-deployment\n"
            "  labels:\n"
            "    app: app\n"
            "spec:\n"
            "  replicas: 2\n"
            "  selector:\n"
            "    matchLabels:\n"
            "      app: app\n"
            "  template:\n"
            "    metadata:\n"
            "      labels:\n"
            "        app: app\n"
            "    spec:\n"
            "      containers:\n"
            "        - name: app\n"
            "          image: your-dockerhub-user/your-image:latest\n"
            "          ports:\n"
            "            - containerPort: 5000\n"
            "          env:\n"
            "            - name: ENVIRONMENT\n"
            '              value: "production"\n'
        )

        service_yaml = (
            "apiVersion: v1\n"
            "kind: Service\n"
            "metadata:\n"
            "  name: app-service\n"
            "  labels:\n"
            "    app: app\n"
            "spec:\n"
            "  type: ClusterIP\n"
            "  selector:\n"
            "    app: app\n"
            "  ports:\n"
            "    - port: 80\n"
            "      targetPort: 5000\n"
        )

        return {
            "deployment.yaml": deployment_yaml,
            "service.yaml": service_yaml,
        }

    # ---------------------- Helm ---------------------- #

    def _generate_helm_chart(
        self,
        language: str,
        framework: Optional[str],
    ) -> Dict[str, str]:
        """
        Simple Helm chart with values + deployment + service.
        (You can replace this later with your more advanced multi-env version.)
        """
        chart_yaml = """apiVersion: v2
name: infragenie-app
description: A sample chart generated by InfraGenie
type: application
version: 0.1.0
appVersion: "1.0.0"
"""

        values_yaml = """replicaCount: 2

image:
  repository: your-dockerhub-user/your-image
  tag: "latest"
  pullPolicy: IfNotPresent

service:
  type: ClusterIP
  port: 80

containerPort: 5000
"""

        deployment_tpl = """apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "infragenie-app.fullname" . }}
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      app: {{ include "infragenie-app.name" . }}
  template:
    metadata:
      labels:
        app: {{ include "infragenie-app.name" . }}
    spec:
      containers:
        - name: {{ .Chart.Name }}
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
          ports:
            - containerPort: {{ .Values.containerPort }}
"""

        service_tpl = """apiVersion: v1
kind: Service
metadata:
  name: {{ include "infragenie-app.fullname" . }}
spec:
  type: {{ .Values.service.type }}
  selector:
    app: {{ include "infragenie-app.name" . }}
  ports:
    - port: {{ .Values.service.port }}
      targetPort: {{ .Values.containerPort }}
"""

        helpers_tpl = """{{- define "infragenie-app.name" -}}
{{- default .Chart.Name .Values.nameOverride | trunc 63 | trimSuffix "-" -}}
{{- end }}

{{- define "infragenie-app.fullname" -}}
{{- if .Values.fullnameOverride -}}
{{- .Values.fullnameOverride | trunc 63 | trimSuffix "-" -}}
{{- else -}}
{{- printf "%s-%s" .Release.Name .Chart.Name | trunc 63 | trimSuffix "-" -}}
{{- end -}}
{{- end }}
"""

        return {
            "Chart.yaml": chart_yaml,
            "values.yaml": values_yaml,
            "templates/_helpers.tpl": helpers_tpl,
            "templates/deployment.yaml": deployment_tpl,
            "templates/service.yaml": service_tpl,
        }

    # ---------------------- ArgoCD ---------------------- #

    def _generate_argocd_app(self, cloud_provider: Optional[str]) -> Dict[str, str]:
        """
        Generates ArgoCD Application YAMLs for:
        - dev
        - stage
        - prod
        plus a root app-of-apps.
        """
        app_dev = """# ArgoCD Application: DEV
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: infragenie-app-dev
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/your-org/your-infra-repo.git
    targetRevision: main
    path: charts/infragenie-app
    helm:
      valueFiles:
        - values-dev.yaml
  destination:
    server: https://kubernetes.default.svc
    namespace: dev
  syncPolicy:
    automated:
      selfHeal: true
      prune: true
"""

        app_stage = """# ArgoCD Application: STAGE
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: infragenie-app-stage
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/your-org/your-infra-repo.git
    targetRevision: main
    path: charts/infragenie-app
    helm:
      valueFiles:
        - values-stage.yaml
  destination:
    server: https://kubernetes.default.svc
    namespace: stage
  syncPolicy:
    automated:
      selfHeal: true
      prune: true
"""

        app_prod = """# ArgoCD Application: PROD
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: infragenie-app-prod
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/your-org/your-infra-repo.git
    targetRevision: main
    path: charts/infragenie-app
    helm:
      valueFiles:
        - values-prod.yaml
  destination:
    server: https://kubernetes.default.svc
    namespace: prod
  syncPolicy:
    automated:
      selfHeal: true
      prune: true
"""

        root_app = """# ArgoCD Root Application (App-of-Apps)
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: infragenie-envs-root
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/your-org/your-infra-repo.git
    targetRevision: main
    path: gitops
  destination:
    server: https://kubernetes.default.svc
    namespace: argocd
  syncPolicy:
    automated:
      selfHeal: true
      prune: true
"""

        return {
            "app-dev.yaml": app_dev,
            "app-stage.yaml": app_stage,
            "app-prod.yaml": app_prod,
            "infragenie-root.yaml": root_app,
        }

    # ---------------------- Terraform (Infra) ---------------------- #

    def _generate_terraform_configs(
        self,
        cloud_provider: str,
        infra_preset: str,
    ) -> Dict[str, Dict[str, str]]:
        """
        Generate minimal Terraform presets:

        - preset = "eks"       -> eks/* files
        - preset = "ec2-k3s"   -> ec2/* files
        - preset = "ecs-fargate" -> ecs/* files
        - preset = "all"       -> all three
        - preset = "none"      -> {}
        """
        provider = (cloud_provider or "aws").lower()
        preset = (infra_preset or "all").lower()

        if provider != "aws":
            return {}

        eks = self._terraform_eks_minimal()
        ec2 = self._terraform_ec2_minimal()
        ecs = self._terraform_ecs_minimal()

        if preset == "none":
            return {}
        if preset == "eks":
            return {"eks": eks}
        if preset in ("ec2", "ec2-k3s"):
            return {"ec2": ec2}
        if preset in ("ecs", "ecs-fargate"):
            return {"ecs": ecs}

        # default: all
        return {
            "eks": eks,
            "ec2": ec2,
            "ecs": ecs,
        }

    def _terraform_common_provider(self) -> str:
        return """terraform {
  required_version = ">= 1.5.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.region
}
"""

    # ---------- EKS minimal preset ---------- #

    def _terraform_eks_minimal(self) -> Dict[str, str]:
        provider_tf = self._terraform_common_provider()

        variables_tf = """variable "region" {
  description = "AWS region"
  type        = string
  default     = "ap-south-1"
}

variable "cluster_name" {
  description = "EKS cluster name"
  type        = string
  default     = "infragenie-eks"
}
"""

        main_tf = """# Minimal EKS cluster generated by InfraGenie
#
# 1) terraform init
# 2) terraform apply
"""

        eks_tf = """resource "aws_eks_cluster" "this" {
  name     = var.cluster_name
  role_arn = "arn:aws:iam::123456789012:role/eks-cluster-role" # TODO: replace

  vpc_config {
    subnet_ids = [] # TODO: fill in subnet IDs
  }
}
"""

        outputs_tf = """output "cluster_name" {
  value = aws_eks_cluster.this.name
}
"""

        return {
            "provider.tf": provider_tf,
            "variables.tf": variables_tf,
            "main.tf": main_tf,
            "eks.tf": eks_tf,
            "outputs.tf": outputs_tf,
        }

    # ---------- EC2 minimal preset ---------- #

    def _terraform_ec2_minimal(self) -> Dict[str, str]:
        provider_tf = self._terraform_common_provider()

        variables_tf = """variable "region" {
  description = "AWS region"
  type        = string
  default     = "ap-south-1"
}

variable "instance_type" {
  description = "EC2 instance type"
  type        = string
  default     = "t3.micro"
}
"""

        main_tf = """resource "aws_instance" "docker_host" {
  ami           = "ami-0e742cca61fb65051"
  instance_type = var.instance_type

  tags = {
    Name = "infragenie-docker-host"
  }
}
"""

        outputs_tf = """output "instance_public_ip" {
  value = aws_instance.docker_host.public_ip
}
"""

        return {
            "provider.tf": provider_tf,
            "variables.tf": variables_tf,
            "main.tf": main_tf,
            "outputs.tf": outputs_tf,
        }

    # ---------- ECS minimal preset ---------- #

    def _terraform_ecs_minimal(self) -> Dict[str, str]:
        provider_tf = self._terraform_common_provider()

        variables_tf = """variable "region" {
  description = "AWS region"
  type        = string
  default     = "ap-south-1"
}
"""

        main_tf = """resource "aws_ecs_cluster" "this" {
  name = "infragenie-ecs-cluster"
}
"""

        outputs_tf = """output "cluster_name" {
  value = aws_ecs_cluster.this.name
}
"""

        return {
            "provider.tf": provider_tf,
            "variables.tf": variables_tf,
            "main.tf": main_tf,
            "outputs.tf": outputs_tf,
        }

    # ---------------------- Monitoring ---------------------- #

    def _generate_monitoring_configs(self) -> Dict[str, str]:
        prometheus_scrape = (
            "scrape_configs:\n"
            "  - job_name: 'infragenie-app'\n"
            "    static_configs:\n"
            "      - targets: ['app-service.default.svc.cluster.local:5000']\n"
        )

        grafana_dashboard = (
            "{\n"
            '  "title": "InfraGenie App Dashboard",\n'
            '  "panels": []\n'
            "}\n"
        )

        return {
            "prometheus-scrape-config.yaml": prometheus_scrape,
            "grafana-dashboard.json": grafana_dashboard,
        }
